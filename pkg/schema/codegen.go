package schema

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

// CodeGenerator generates Go code (structs and enums) from the schema IR
// (TypeDefinition values). It writes generated .go files into the specified
// output directory. This generator is intentionally conservative and focuses
// on producing readable, idiomatic Go that can be iterated on.
type CodeGenerator struct {
	// PackageName is the package name to use for generated files (default "generated")
	PackageName string
	// Author optionally included in header comment
	Author string
}

// Ensure CodeGenerator implements Generator
var _ Generator = (*CodeGenerator)(nil)

// GenerateFromSchemas implements Generator. It parses the provided Schema
// values (by delegating to ParseSchemas) and emits Go code into outDir.
func (g *CodeGenerator) GenerateFromSchemas(schemas []*Schema, outDir string) error {
	if g.PackageName == "" {
		g.PackageName = "generated"
	}
	types, err := ParseSchemas(schemas)
	if err != nil {
		return fmt.Errorf("parse schemas: %w", err)
	}
	// Sort type names for deterministic output
	sort.Slice(types, func(i, j int) bool { return types[i].Name < types[j].Name })

	// Ensure output directory exists
	if err := os.MkdirAll(outDir, 0o755); err != nil {
		return fmt.Errorf("create outdir: %w", err)
	}

	// Build the content of one file with all types for simplicity
	var buf bytes.Buffer
	if err := emitHeader(&buf, g.PackageName, g.Author); err != nil {
		return err
	}

	// Collect any imports needed (e.g., time, encoding/base64) - for now we may need encoding/xml
	imports := map[string]struct{}{}
	// We'll always include encoding/xml tag usage for marshaling helpers/clarity
	imports["encoding/xml"] = struct{}{}

	// Emit types
	for _, td := range types {
		// Skip unnamed or empty names
		if strings.TrimSpace(td.Name) == "" {
			continue
		}
		// If this is an enum
		if td.IsEnum && len(td.EnumValues) > 0 {
			if err := emitEnum(&buf, td); err != nil {
				return err
			}
			continue
		}
		// Otherwise emit struct
		if err := emitStruct(&buf, td, imports); err != nil {
			return err
		}
	}

	// Prepend imports section
	var out bytes.Buffer
	if err := emitPackageAndImports(&out, g.PackageName, imports); err != nil {
		return err
	}
	// Then the previously rendered types
	if _, err := out.Write(buf.Bytes()); err != nil {
		return err
	}

	// Format the generated source
	src, err := format.Source(out.Bytes())
	if err != nil {
		// On formatting error, write unformatted content for debugging
		_ = os.WriteFile(filepath.Join(outDir, "zz_generated_unformatted.go"), out.Bytes(), 0o644)
		return fmt.Errorf("gofmt failed: %w (unformatted saved to zz_generated_unformatted.go)", err)
	}

	// Write to file
	target := filepath.Join(outDir, "zz_generated_types.go")
	if err := os.WriteFile(target, src, 0o644); err != nil {
		return fmt.Errorf("write generated file: %w", err)
	}
	return nil
}

// emitHeader writes a top-of-file comment describing generation provenance.
func emitHeader(buf *bytes.Buffer, pkg string, author string) error {
	header := `// Code generated by exi-go codegen.
// DO NOT EDIT.
//
// Package: {{ .Pkg }}
// Author:  {{ .Author }}
//
// This file was produced by an XSD -> IR -> code generator. It contains
// Go representations (structs and enums) derived from the provided XML
// Schema intermediate representation.
//
// The generator is intentionally conservative. Review the generated output
// and extend the generator to handle additional XSD constructs as needed.

`
	t := template.Must(template.New("hdr").Parse(header))
	return t.Execute(buf, map[string]string{"Pkg": pkg, "Author": author})
}

// emitPackageAndImports writes the package declaration and import block (if any).
func emitPackageAndImports(buf *bytes.Buffer, pkg string, imports map[string]struct{}) error {
	fmt.Fprintf(buf, "package %s\n\n", pkg)
	if len(imports) == 0 {
		return nil
	}
	// stable ordering
	var keys []string
	for k := range imports {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	fmt.Fprintln(buf, "import (")
	for _, k := range keys {
		fmt.Fprintf(buf, "\t%q\n", k)
	}
	fmt.Fprintln(buf, ")")
	return nil
}

// emitEnum emits a typed string enum using the XSD enumeration values.
func emitEnum(buf *bytes.Buffer, td *TypeDefinition) error {
	// Type name: sanitize and make exported
	tn := exportName(td.Name)
	// Emit type and const block
	fmt.Fprintf(buf, "// %s is an enumeration corresponding to XSD simpleType %s\n", tn, td.Name)
	fmt.Fprintf(buf, "type %s string\n\n", tn)
	fmt.Fprintf(buf, "const (\n")
	for i, v := range td.EnumValues {
		cname := exportName(td.Name + "_" + v)
		// Ensure constant name is valid Go identifier
		fmt.Fprintf(buf, "\t%s %s = %#v", cname, tn, v)
		if i == 0 {
			fmt.Fprintf(buf, " // first value\n")
		} else {
			fmt.Fprintln(buf)
		}
	}
	fmt.Fprintln(buf, ")")
	return nil
}

// emitStruct emits a Go struct for the provided TypeDefinition. It updates
// imports map with any additional imports required for special types.
func emitStruct(buf *bytes.Buffer, td *TypeDefinition, imports map[string]struct{}) error {
	name := exportName(td.Name)
	if name == "" {
		return nil
	}
	fmt.Fprintf(buf, "// %s represents XSD complexType/element %s\n", name, td.Name)
	fmt.Fprintf(buf, "type %s struct {\n", name)

	// Add XMLName to help with marshaling/unmarshaling
	fmt.Fprintf(buf, "\tXMLName xml.Name `xml:\"%s\"`\n", td.Name)

	for _, f := range td.Fields {
		fieldName := exportName(f.Name)
		if fieldName == "" {
			// fallback generate a safe name
			fieldName = "Field"
		}
		goType := mapXSDTypeToGo(f.Type, f.IsArray)
		if goType == "[]byte" {
			// we use base64 or hex for these in XML marshaling; still keep import note
			imports["encoding/base64"] = struct{}{}
		}
		tagName := f.Name
		tag := fmt.Sprintf("`xml:\"%s", tagName)
		// add omitempty for optional fields or slices
		if f.IsOptional || f.IsArray {
			tag += ",omitempty"
		}
		tag += "\"`"
		fmt.Fprintf(buf, "\t%s %s %s\n", fieldName, goType, tag)
	}
	fmt.Fprintln(buf, "}")
	return nil
}

// mapXSDTypeToGo maps basic XSD types (or type names) to Go types. This is a
// pragmatic mapping and should be extended to cover more XSD built-ins and
// custom types as required by the generator.
func mapXSDTypeToGo(xsdType string, asArray bool) string {
	// Remove namespace prefix if present (e.g. xsd:base64Binary -> base64Binary)
	if idx := strings.Index(xsdType, ":"); idx != -1 {
		xsdType = xsdType[idx+1:]
	}
	lt := strings.ToLower(xsdType)

	// Explicit handling for binary types: map base64Binary and hexBinary to []byte.
	// This ensures generated Go types use []byte for binary content rather than string.
	if lt == "hexbinary" || strings.Contains(lt, "hexbinary") || strings.Contains(lt, "hex") && strings.Contains(lt, "binary") {
		if asArray {
			return "[][]byte"
		}
		return "[]byte"
	}
	if lt == "base64binary" || strings.Contains(lt, "base64") || strings.Contains(lt, "base64binary") {
		if asArray {
			return "[][]byte"
		}
		return "[]byte"
	}

	// basic XSD -> Go mappings
	switch lt {
	case "string", "normalizedstring", "token", "language", "nmtoken":
		if asArray {
			return "[]string"
		}
		return "string"
	case "boolean":
		if asArray {
			return "[]bool"
		}
		return "bool"
	case "byte", "short", "int", "integer", "long", "nonnegativeinteger", "positiveinteger":
		// default to int64 for numeric types for safety
		if asArray {
			return "[]int64"
		}
		return "int64"
	case "unsignedint", "unsignedshort", "unsignedbyte":
		if asArray {
			return "[]uint64"
		}
		return "uint64"
	case "decimal", "float", "double":
		if asArray {
			return "[]float64"
		}
		return "float64"
	case "":
		// unknown type: fallback to string
		if asArray {
			return "[]string"
		}
		return "string"
	default:
		// Unknown or user-defined type - map to corresponding Go struct/alias
		// Convert to exported name
		gn := exportName(xsdType)
		if asArray {
			return "[]" + gn
		}
		return gn
	}
}

// exportName converts an arbitrary identifier into a Go exported identifier
// using a conservative CamelCase strategy. It removes invalid characters and
// ensures the first character is a letter.
func exportName(s string) string {
	if s == "" {
		return ""
	}
	// Replace non-alphanumeric with spaces, then Title-case and remove spaces
	// Also handle underscores and dashes.
	sep := regexp.MustCompile(`[^0-9A-Za-z]+`)
	parts := sep.Split(s, -1)
	var out string
	for _, p := range parts {
		if p == "" {
			continue
		}
		out += strings.Title(strings.ToLower(p))
	}
	// Ensure it starts with a letter; if not, prefix with X
	if out == "" {
		return ""
	}
	if !(('A' <= out[0] && out[0] <= 'Z') || ('a' <= out[0] && out[0] <= 'z')) {
		out = "X" + out
	}
	return out
}

// hasInlineChild is unused here; parse routines call dedicated helpers.
// Keep as a small utility if needed by future extensions.
func hasInlineChildPlaceholder() bool { return false }
